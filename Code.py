# -*- coding: utf-8 -*-
"""Copy of 0806smts.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ECkXA-6SX1GYubxXeKG_IPhJdRaD7VQE
"""

import json

# Load simulated data
with open("simulated_weather_chandigarh.json", "r") as f:
    data = json.load(f)

# Parse and display
weather_description = data['weather'][0]['description']
temp = data['main']['temp']
print(f"Weather in Chandigarh: {weather_description}, Temp: {temp}¬∞C")

import json

# Choose the file to simulate (e.g., rain, storm)
filename = "weather_rain.json"

with open("data/simulated_weather_chandigarh.json", "r") as f:
    data = json.load(f)

condition = data['weather'][0]['description']
temp = data['main']['temp']

# Simulate signal adjustment
if "rain" in condition or "storm" in condition:
    signal_duration = "Longer green/red cycles for slower traffic"
elif "fog" in condition or "smoke" in condition:
    signal_duration = "Activate flashing amber signals"
else:
    signal_duration = "Normal timing"

print(f"Condition: {condition}, Temp: {temp}¬∞C")
print("üö¶ Signal Strategy:", signal_duration)

# Commented out IPython magic to ensure Python compatibility.
# üö¶ Smart Traffic Signal System with Images + Weather Integration

# STEP 1: Setup YOLOv5
!git clone https://github.com/ultralytics/yolov5
# %cd yolov5
# %pip install -r requirements.txt

import torch
import time
from PIL import Image
import json

# STEP 2: Load the YOLOv5 model
model = torch.hub.load('ultralytics/yolov5', 'yolov5s')

# STEP 3: Load 4 image paths from Colab
image_paths = {
    "Phase 1": "images/phase1.png",
    "Phase 2": "images/phase2.png",
    "Phase 3": "images/phase3.png",
    "Phase 4": "images/phase4.png"
}

# STEP 4: Detect vehicles in each phase image
vehicle_counts = {}
for phase, path in image_paths.items():
    img = Image.open(path)
    results = model(img)
    detected_classes = results.pred[0][:, -1]

    # Classes: car=2, motorcycle=3, bus=5, truck=7
    count = sum(1 for c in detected_classes if int(c) in [2, 3, 5, 7])
    vehicle_counts[phase] = count
    print(f"{phase}: {count} vehicles")

# STEP 5: Load weather data from simulated JSON
with open("/content/simulated_weather_chandigarh.json", "r") as f:
    weather_data = json.load(f)

condition = weather_data['weather'][0]['description'].lower()
temp = weather_data['main']['temp']

# Adjust signal behavior based on condition
if "rain" in condition or "storm" in condition:
    signal_strategy = "Longer green/red cycles for slower traffic"
    weather_condition = "rain"
elif "fog" in condition or "smoke" in condition:
    signal_strategy = "Activate flashing amber signals"
    weather_condition = "fog"
else:
    signal_strategy = "Normal timing"
    weather_condition = "clear"

print(f"\nüì° Weather Report")
print(f"üå¶Ô∏è Condition: {condition}")
print(f"üå°Ô∏è Temperature: {temp}¬∞C")
print(f"üö¶ Signal Strategy: {signal_strategy}")

# STEP 6: Function to allocate green signal times dynamically
def allocate_green_times(vehicle_counts, weather_condition="clear", total_cycle_time=80, yellow=4, min_green=8):
    total_yellow = yellow * len(vehicle_counts)
    available_green = total_cycle_time - total_yellow
    total_vehicles = sum(vehicle_counts.values())

    green_times = {}
    for phase, count in vehicle_counts.items():
        if total_vehicles == 0:
            green = available_green / len(vehicle_counts)
        else:
            green = max(min_green, (count / total_vehicles) * available_green)

        # Weather adjustment
        if weather_condition in ["rain", "storm"]:
            green += 5
        elif weather_condition in ["fog", "smog"]:
            green *= 1.2

        green_times[phase] = min(int(green), 60)  # Cap to 60 seconds

    return green_times

# STEP 7: Allocate green signal times
green_times = allocate_green_times(vehicle_counts, weather_condition)

# STEP 8: Simulate traffic signal operation for two phases green together
# Define phase pairs that can go green together (non-conflicting)
phase_pairs = [("Phase 1", "Phase 3"), ("Phase 2", "Phase 4")]

print(f"\nüö¶ Updated Traffic Signal Timings (Two Phases Green):")
for pair in phase_pairs:
    p1, p2 = pair
    green_time = max(green_times[p1], green_times[p2])  # take max for sync
    yellow_time = 4

    red_phases = [p for p in vehicle_counts if p not in pair]
    red_time = sum(green_times[p] + yellow_time for p in red_phases)

    print(f"\nüîÅ {p1} & {p2} GREEN")
    print(f"üü¢ GREEN: {green_time}s")
    print(f"üü° YELLOW: {yellow_time}s")
    print(f"üî¥ RED: {red_time}s for others")

    print(f"‚úÖ GREEN ON: {p1} + {p2}")
    time.sleep(2)  # Replace with green_time in real scenario

    print("üü° YELLOW ON")
    time.sleep(1)  # Replace with yellow_time in real scenario

    print("üî¥ RED ON")

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/ultralytics/yolov5
# %cd yolov5
# %pip install -r requirements.txt

import torch
import time
from PIL import Image
import json

# STEP 2: Load the YOLOv5 model
model = torch.hub.load('ultralytics/yolov5', 'yolov5s')

# Commented out IPython magic to ensure Python compatibility.
# üö¶ Smart Traffic Signal System with Emergency Vehicle Detection (CNN + OCR + Debug)

# STEP 1: Setup
!git clone https://github.com/ultralytics/yolov5
# %cd yolov5
!pip install -r requirements.txt
!pip install easyocr

import torch
import time
import json
import numpy as np
import cv2
from PIL import Image
import easyocr
import matplotlib.pyplot as plt
import os

reader = easyocr.Reader(['en'])

def preprocess_for_ocr(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    resized = cv2.resize(gray, (300, 100))
    _, thresh = cv2.threshold(resized, 120, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    return cv2.cvtColor(thresh, cv2.COLOR_GRAY2RGB)

# === Placeholder for CNN logic (user should integrate their trained model)
def cnn_emergency_classifier(crop_img):
    # TODO: Replace this with your actual model logic
    return False

def ocr_emergency_classifier(crop_img):
    processed_img = preprocess_for_ocr(crop_img)
    results = reader.readtext(processed_img)
    for _, text, _ in results:
        print(f"üî† OCR found text: {text}")
        if 'ambulance' in text.lower() or 'emergency' in text.lower():
            return True
    return False

def emergency_vehicle_classifier(crop_img):
    print("üîç Checking vehicle crop...")
    if cnn_emergency_classifier(crop_img):
        print("‚úÖ CNN: Detected ambulance")
        return True
    if ocr_emergency_classifier(crop_img):
        print("‚úÖ OCR: Detected ambulance text")
        return True
    print("‚ùå No emergency found")
    return False

# STEP 2: Load the YOLOv5 model
model = torch.hub.load('ultralytics/yolov5', 'yolov5s')

# STEP 3: Load 4 image paths
image_paths = {
    "Phase 1": "images/phase1.png",
    "Phase 2": "images/phase2.png",
    "Phase 3": "images/phase3.png",
    "Phase 4": "images/phase4.png"
}

# STEP 4: Detect vehicles and check for emergency vehicles
vehicle_counts = {}
emergency_detected_phases = []

os.makedirs("crops", exist_ok=True)

for phase, path in image_paths.items():
    img = Image.open(path)
    results = model(img)
    detected_classes = results.pred[0][:, -1]
    vehicle_counts[phase] = sum(1 for c in detected_classes if int(c) in [2, 3, 5, 7])

    image_np = np.array(img)
    for i, det in enumerate(results.pred[0]):
        x1, y1, x2, y2, conf, cls_id = det
        if int(cls_id) in [2, 3, 5, 7]:
            crop = image_np[int(y1):int(y2), int(x1):int(x2)]
            crop_bgr = cv2.cvtColor(crop, cv2.COLOR_RGB2BGR)
            cv2.imwrite(f"crops/{phase.replace(' ', '_')}_veh_{i}.jpg", crop_bgr)
            plt.imshow(crop)
            plt.title(f"{phase} Crop {i}")
            plt.axis('off')
            plt.show()
            if emergency_vehicle_classifier(crop_bgr):
                emergency_detected_phases.append(phase)
                print(f"üö® Emergency vehicle detected in {phase}")
                break
    print(f"{phase}: {vehicle_counts[phase]} vehicles")

# STEP 5: Load weather
with open("data/simulated_weather_chandigarh.json", "r") as f:
    weather_data = json.load(f)

condition = weather_data['weather'][0]['description'].lower()
temp = weather_data['main']['temp']
weather_condition = (
    "rain" if "rain" in condition or "storm" in condition else
    "fog" if "fog" in condition or "smoke" in condition else "clear"
)

print(f"\nüì± Weather Report")
print(f"üå¶Ô∏è Condition: {condition}")
print(f"üå°Ô∏è Temperature: {temp}¬∞C")

# STEP 6: Allocate green times
def allocate_green_times(vehicle_counts, weather_condition="clear", total_cycle_time=80, yellow=4, min_green=8):
    total_yellow = yellow * len(vehicle_counts)
    available_green = total_cycle_time - total_yellow
    total_vehicles = sum(vehicle_counts.values())

    green_times = {}
    for phase, count in vehicle_counts.items():
        green = max(min_green, (count / total_vehicles) * available_green) if total_vehicles else available_green / len(vehicle_counts)
        if weather_condition == "rain": green += 5
        elif weather_condition == "fog": green *= 1.2
        green_times[phase] = min(int(green), 60)
    return green_times

green_times = allocate_green_times(vehicle_counts, weather_condition)

# STEP 7: Emergency override
e_merg_timer = 15
if emergency_detected_phases:
    print(f"\nüö® Emergency Detected in: {', '.join(emergency_detected_phases)}")
    for phase in emergency_detected_phases:
        print(f"\n‚úÖ GREEN for Emergency Phase: {phase}")
        print(f"üü¢ GREEN: {e_merg_timer}s")
        time.sleep(2)
        print("üü° YELLOW ON")
        time.sleep(1)
        print("üî¥ RED ON")
    print("\n‚è≠Ô∏è Resuming Normal Cycle...\n")

# STEP 8: Simulate traffic signal cycle
phase_pairs = [("Phase 1", "Phase 3"), ("Phase 2", "Phase 4")]

print(f"\nüö¶ Updated Traffic Signal Timings (Two Phases Green):")
for pair in phase_pairs:
    p1, p2 = pair
    green_time = max(green_times[p1], green_times[p2])
    yellow_time = 4
    red_time = sum(green_times[p] + yellow_time for p in green_times if p not in pair)

    print(f"\nüîÅ {p1} & {p2} GREEN")
    print(f"üü¢ GREEN: {green_time}s")
    print(f"üü° YELLOW: {yellow_time}s")
    print(f"üî¥ RED: {red_time}s for others")

    print(f"‚úÖ GREEN ON: {p1} + {p2}")
    time.sleep(2)
    print("üü° YELLOW ON")
    time.sleep(1)
    print("üî¥ RED ON")

